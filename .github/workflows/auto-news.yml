name: Auto Newser

on:
  schedule:
    - cron: '0 0 * * *'   # 3AM EAT (Sports)
    - cron: '0 6 * * *'   # 9AM EAT (Tech)
    - cron: '0 11 * * *'  # 2PM EAT (Finance/Business)
    - cron: '0 14 * * *'  # 5PM EAT (Sports)
    - cron: '0 18 * * *'  # 9PM EAT (Finance/Business)
    - cron: '0 22 * * *'  # 1AM EAT (Tech)
  workflow_dispatch:
    inputs:
      manual_topic:
        description: 'Force a topic (sports, technology, business, politics, entertainment)'
        required: false
        default: ''

permissions:
  contents: write

env:
  DEFAULT_BRANCH: main
  POSTS_DIR: src/content/posts
  MEMORY_FILE: .github/scrape_memory.json

jobs:
  generate-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 
          ref: ${{ env.DEFAULT_BRANCH }}
          token: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests google-genai apify-client beautifulsoup4

      - name: Generate article with Gemini
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_API_KEY1: ${{ secrets.GEMINI_API_KEY1 }}
          GEMINI_API_KEY2: ${{ secrets.GEMINI_API_KEY2 }}
          GEMINI_WRITE_KEY: ${{ secrets.GEMINI_WRITE_KEY }}
          APIFY_API_TOKEN: ${{ secrets.APIFY_API_TOKEN }}
          APIFY_API_TOKEN1: ${{ secrets.APIFY_API_TOKEN1 }}
          APIFY_API_TOKEN2: ${{ secrets.APIFY_API_TOKEN2 }}
          APIFY_API_TOKEN3: ${{ secrets.APIFY_API_TOKEN3 }}
          APIFY_API_TOKEN4: ${{ secrets.APIFY_API_TOKEN4 }}
          APIFY_API_TOKEN5: ${{ secrets.APIFY_API_TOKEN5 }}
          UNSPLASH_ACCESS_KEY: ${{ secrets.UNSPLASH_ACCESS_KEY }}
          MANUAL_TOPIC: ${{ inputs.manual_topic }}
          MEMORY_FILE: ${{ env.MEMORY_FILE }}
          CRON_SCHEDULE: ${{ github.event.schedule }}
        run: |
          python << 'EOF'
          import os, json, datetime, requests, re, random, time, hashlib
          from google import genai
          from google.genai import types
          from apify_client import ApifyClient
          from bs4 import BeautifulSoup
          import textwrap

          # --- 1. HELPERS: KEYS & INTERNAL LINKS ---
          def get_gemini_key():
              cron = os.environ.get('CRON_SCHEDULE', '')
              key_map = {'0 0 * * *': 'GEMINI_API_KEY', '0 6 * * *': 'GEMINI_API_KEY1', '0 11 * * *': 'GEMINI_API_KEY2', '0 14 * * *': 'GEMINI_API_KEY', '0 18 * * *': 'GEMINI_API_KEY1', '0 22 * * *': 'GEMINI_WRITE_KEY'}
              target = key_map.get(cron, 'GEMINI_WRITE_KEY')
              return os.environ.get(target) or os.environ.get('GEMINI_WRITE_KEY')

          def get_internal_link_context():
              p_path = os.environ.get('POSTS_DIR')
              if not os.path.exists(p_path): return ""
              files = [f for f in os.listdir(p_path) if f.endswith('.md')]
              if not files: return ""
              sample = random.sample(files, min(len(files), 3))
              ctx = "PAST ARTICLES FOR INTERNAL LINKING:\n"
              for f in sample:
                  try:
                      with open(os.path.join(p_path, f), 'r') as c:
                          txt = c.read()
                          t_match = re.search(r'title:\s*"(.*?)"', txt)
                          ctx += f"- {t_match.group(1) if t_match else f}: /posts/{f.replace('.md', '')}\n"
                  except: continue
              return ctx

          # --- 2. TOPIC & CATEGORY URL MAPPING ---
          current_hour_utc = datetime.datetime.utcnow().hour
          manual = os.environ.get('MANUAL_TOPIC', '').strip().lower()
          topic = manual if manual in ['sports', 'technology', 'business', 'politics', 'entertainment'] else ('sports' if current_hour_utc in [0, 14] else 'technology' if current_hour_utc in [6, 22] else 'business' if current_hour_utc in [11, 18] else 'politics')
          
          url_map = {
              'politics': 'https://www.kenyamoja.com/news/kenyans',
              'sports': 'https://www.kenyamoja.com/sports',
              'entertainment': 'https://www.kenyamoja.com/entertainment',
              'technology': 'https://www.kenyamoja.com/technology',
              'business': 'https://www.kenyamoja.com/business'
          }
          km_url = url_map.get(topic, 'https://www.kenyamoja.com/news/kenyans')
          
          memory_path = os.environ.get('MEMORY_FILE')
          memory = json.load(open(memory_path)) if os.path.exists(memory_path) else []
          
          full_raw_text, final_hash = None, None
          try:
              res = requests.get(km_url, headers={'User-Agent': 'Mozilla/5.0'}, timeout=20)
              news_items = BeautifulSoup(res.text, 'html.parser').select('li.news-item')
              
              apify_pool = [os.environ.get(v) for v in ['APIFY_API_TOKEN', 'APIFY_API_TOKEN1', 'APIFY_API_TOKEN2', 'APIFY_API_TOKEN3', 'APIFY_API_TOKEN4', 'APIFY_API_TOKEN5'] if os.environ.get(v)]
              client_apify = ApifyClient(random.choice(apify_pool))

              for item in news_items:
                  link_tag = item.select_one('.news-title a')
                  if link_tag and 'href' in link_tag.attrs:
                      url = link_tag['href']
                      u_hash = hashlib.md5(url.encode()).hexdigest()
                      if u_hash not in memory and url.startswith("http"):
                          print(f"ðŸ•·ï¸ Scrape start: {url}")
                          run = client_apify.actor("apify/website-content-crawler").call(run_input={"startUrls": [{"url": url}], "maxCrawlPages": 1, "crawlerType": "playwright:firefox"})
                          data = list(client_apify.dataset(run["defaultDatasetId"]).iterate_items())
                          if data:
                              text = data[0].get('markdown', data[0].get('text', ''))
                              if len(text) > 800:
                                  full_raw_text, final_hash = text, u_hash
                                  break
          except Exception as e:
              print(f"Discovery Error: {e}"); exit(0)

          if not full_raw_text: exit(0)

          # --- 3. THE HUMAN CORE & GEO PROMPT ---
          internal_linking = get_internal_link_context()
          prompt = f"""OPERATE AS HUMAN INTELLIGENCE DISGUISED AS CONVERSATION.
          Write a 1700-word investigative report.
          SOURCE: {full_raw_text[:15000]}
          {internal_linking}

          STYLE GUIDE:
          - ANSWER-FIRST (GEO): Answer core news hook in the first two paragraphs.
          - HUMAN RHYTHM: Blunt fragments, human asides, cynical authoritative tone.
          - NO AI SLOP: Ban 'tapestry', 'delve', 'testament', 'vibrant', 'realm'.
          - NO CONCLUSION: Never use 'In conclusion'. Stop abruptly.
          - CONTRARIAN: Frame from the DIRECTLY OPPOSITE angle of mainstream media.
          - LINKING: Naturally weave in 1 slug from the provided past articles.

          STRICT: NO EM-DASHES. UK English. ## Headers. 

          OUTPUT FORMAT:
          TITLE: [headline]
          DESCRIPTION: [summary]
          IMAGE_CAPTION: [cynical caption]
          CATEGORY: [{topic.title()}]
          TAGS: [3 tags]
          IMAGE_KEYWORD: [2 words]
          BODY:
          [Article Content]"""

          # --- 4. GENERATION & GREEDY PARSING ---
          client_gemini = genai.Client(api_key=get_gemini_key())
          resp = client_gemini.models.generate_content(
              model="gemini-3-flash-preview", contents=prompt, 
              config=types.GenerateContentConfig(temperature=0.88, max_output_tokens=8192)
          )
          raw_output = resp.text.strip()

          def get_field(field_name, text):
              match = re.search(rf"^{field_name}:\s*(.*)", text, re.M | re.I)
              return match.group(1).strip() if match else None

          parsed = {
              "TITLE": get_field("TITLE", raw_output) or "Analysis",
              "DESC": get_field("DESCRIPTION", raw_output) or "Report.",
              "CAPTION": get_field("IMAGE_CAPTION", raw_output) or "Status quo.",
              "TAGS": get_field("TAGS", raw_output) or topic,
              "IMG": get_field("IMAGE_KEYWORD", raw_output) or topic,
              "BODY": ""
          }

          # GREEDY PARSER: Everything after 'BODY:'
          body_match = re.search(r"BODY:\s*(.*)", raw_output, re.S | re.I)
          if body_match:
              parsed["BODY"] = body_match.group(1).strip()
          else:
              # Last resort fallback if tag is missing
              parsed["BODY"] = raw_output.split(parsed["IMG"])[-1].strip()

          if len(parsed["BODY"]) < 1000:
              print("âŒ Rejection: Article incomplete."); exit(1)

          for k in parsed:
              parsed[k] = parsed[k].replace("â€”", ", ").replace("â€“", ", ").replace("--", ", ")
              parsed[k] = re.sub(r'(?i)(In conclusion|Summary|To summarize|Conclusion),?.*', '', parsed[k]).strip()

          # --- 6. SCHEMA & SAVE ---
          u_key = os.environ.get("UNSPLASH_ACCESS_KEY")
          def get_img(q):
              try:
                  r = requests.get(f"https://api.unsplash.com/photos/random?query={q}&orientation=landscape&client_id={u_key}", timeout=10)
                  return r.json()['urls']['regular']
              except: return "https://images.unsplash.com/photo-1504711432869-efd597cdd042"

          img_url = get_img(parsed['IMG'])
          slug = re.sub(r'[^a-z0-9-]', '-', parsed["TITLE"].lower()).strip('-')
          date_now = datetime.datetime.utcnow().date().strftime('%Y-%m-%d')

          schema = {
              "@context": "https://schema.org",
              "@type": "AnalysisNewsArticle",
              "headline": parsed['TITLE'],
              "description": parsed['DESC'],
              "author": {"@type": "Person", "name": "Belinda Achieng'"},
              "datePublished": date_now,
              "image": [img_url]
          }

          final_md = textwrap.dedent(f"""---
          title: "{parsed['TITLE'].replace('"', "'")}"
          description: "{parsed['DESC'].replace('"', "'")}"
          date: "{date_now}"
          author: "Belinda Achieng'"
          image: "{img_url}"
          imageCaption: "{parsed['CAPTION'].replace('"', "'")}"
          category: "{topic.title()}"
          tags: {json.dumps([t.strip() for t in parsed["TAGS"].split(",")])}
          slug: "{slug}"
          ---

          {parsed['BODY']}

          <script type="application/ld+json">
          {json.dumps(schema, indent=2)}
          </script>
          """).strip()

          o_dir = os.environ.get("POSTS_DIR")
          os.makedirs(o_dir, exist_ok=True)
          with open(os.path.join(o_dir, f"{slug}.md"), "w", encoding="utf-8") as f: f.write(final_md)
          
          memory.append(final_hash)
          with open(memory_path, 'w') as f: json.dump(memory[-200:], f)
          print(f"âœ… Published: {slug}")
          EOF

      - name: Git Safety Pull
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git stash -u
          git fetch origin main
          git pull origin main --rebase
          git stash pop || echo "Nothing to pop"

      - name: Commit and push article
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "content: human-core publish ${{ github.run_id }}"
          branch: ${{ env.DEFAULT_BRANCH }}
          file_pattern: '${{ env.POSTS_DIR }}/*.md .github/scrape_memory.json'
        env:
          GITHUB_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}