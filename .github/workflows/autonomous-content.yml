name: Global Scandal Hunter (SEO-Safe)

on:
  schedule:
    # 5:15 AM EAT: Politics (The "Morning Coffee" Scandal)
    - cron: '15 2 * * *'   
    # 8:15 AM EAT: Relationship/Lifestyle Drama
    - cron: '15 5 * * *'   
    # 11:15 AM EAT: Tech Leaks/Hacks
    - cron: '15 8 * * *'   
    # 2:15 PM EAT: Crime & Safety
    - cron: '15 11 * * *'  
    # 5:15 PM EAT: Entertainment/Celeb Gossip
    - cron: '15 14 * * *'  
    # 9:15 PM EAT: Late Night Confessions
    - cron: '15 18 * * *'  
  workflow_dispatch:
    inputs:
      manual_topic:
        description: 'Force a topic'
        required: false
        default: ''

permissions:
  contents: write

env:
  DEFAULT_BRANCH: main
  POSTS_DIR: src/content/posts
  MEMORY_FILE: .github/scrape_memory.json

jobs:
  generate-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.DEFAULT_BRANCH }}
          token: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests google-genai

      - name: Generate Content
        env:
          GEMINI_POOL: "${{ secrets.GEMINI_API_KEY }},${{ secrets.GEMINI_API_KEY1 }},${{ secrets.GEMINI_API_KEY2 }},${{ secrets.GEMINI_WRITE_KEY }}"
          NEWSAPI_KEY: ${{ secrets.NEWSAPI_KEY }}
          UNSPLASH_ACCESS_KEY: ${{ secrets.UNSPLASH_ACCESS_KEY }}
          MANUAL_TOPIC: ${{ github.event.inputs.manual_topic }}
          MEMORY_FILE: ${{ env.MEMORY_FILE }}
          CRON_SCHEDULE: ${{ github.event.schedule }}
        run: |
          python << 'EOF'
          import os, json, datetime, requests, re, random, hashlib, time
          from google import genai
          from google.genai import types
          import textwrap

          # --- 1. SETUP ---
          def get_clean_pool(v): return [k.strip() for k in v.split(",") if k.strip()]
          gem_pool = get_clean_pool(os.environ.get("GEMINI_POOL", ""))

          # SEO FIX: Robust Internal Linking Context
          def get_internal_context():
              posts_dir = os.environ.get("POSTS_DIR")
              if not os.path.exists(posts_dir): return ""
              files = [f for f in os.listdir(posts_dir) if f.endswith('.md')]
              if not files: return ""
              sample = random.sample(files, min(len(files), 4)) # Increased sample size
              context = "PAST ARTICLES (FOR CONTEXT & LINKING):\n"
              for f in sample:
                  try:
                      with open(os.path.join(posts_dir, f), 'r') as content:
                          txt = content.read()
                          title_match = re.search(r'title:\s*"(.*?)"', txt)
                          title = title_match.group(1) if title_match else f
                          context += f"- {title}: /posts/{f.replace('.md', '')}\n"
                  except: continue
              return context

          def run_gemini(p):
              random.shuffle(gem_pool)
              for k in gem_pool:
                  try:
                      client = genai.Client(api_key=k)
                      return client.models.generate_content(
                          model="gemini-2.0-flash", 
                          contents=p,
                          config=types.GenerateContentConfig(temperature=0.9, max_output_tokens=8192)
                      ).text.strip()
                  except Exception as e:
                      print(f"Key Failed: {e}"); continue
              return None

          # --- 2. TOPIC SELECTION (No Biz, No Sports) ---
          cron_map = {
              '15 2 * * *': 'politics',
              '15 5 * * *': 'relationships',
              '15 8 * * *': 'technology',
              '15 11 * * *': 'crime',
              '15 14 * * *': 'entertainment',
              '15 18 * * *': 'confessions'
          }
          topic = os.environ.get('MANUAL_TOPIC', '').lower() or cron_map.get(os.environ.get('CRON_SCHEDULE', ''), 'politics')
          
          # SEO FIX: Refined Queries to find "High Voltage" but "Credible" drama
          query_map = {
              'politics': 'scandal OR corruption OR exposed OR secret',
              'relationships': 'drama OR cheating OR divorce OR scandal',
              'technology': 'hack OR leak OR lawsuit OR danger', 
              'crime': 'heist OR fraud OR scam OR cartel',
              'entertainment': 'feud OR viral OR exposed OR controversy',
              'confessions': 'shocking OR mystery OR secret'
          }
          query = query_map.get(topic, topic)

          memory_path = os.environ.get('MEMORY_FILE')
          memory = json.load(open(memory_path)) if os.path.exists(memory_path) else []

          news_api = os.environ.get("NEWSAPI_KEY")
          # Sorting by relevancy to get better matches for specific keywords
          news_url = f"https://newsapi.org/v2/everything?q={query}&language=en&sortBy=relevancy&apiKey={news_api}"
          
          try:
              articles = requests.get(news_url).json().get('articles', [])
          except: exit(0)

          target_article, final_hash = None, None
          for a in articles:
              u = a.get('url', '')
              h = hashlib.md5(u.encode()).hexdigest()
              
              # --- FIX IS HERE: Force description to string ---
              desc = a.get('description') or ""
              
              if h not in memory and len(desc) > 50:
                  target_article = a
                  final_hash = h
                  break

          if not target_article:
              print("No new content found."); exit(0)

          # --- 3. PROMPT: THE TRUSTED INSIDER ---
          internal_linking = get_internal_context()
          prompt = f"""OPERATE AS A SAVAGE BUT CREDIBLE INSIDER COLUMNIST. 
          
          SOURCE TITLE: {target_article['title']}
          SOURCE SUMMARY: {target_article['description']}
          
          {internal_linking}

          MANDATE:
          1. HEADLINE: Use "Curiosity Gap" + "Specific Benefit". AVOID vague clickbait.
             - BAD: "You Won't Believe This!"
             - GOOD: "The $5B Mistake: Why the New Tax Law Actually Robs You."
          2. ANGLE: Focus on the "Hidden Cost" or "Secret Motive."
          3. ANSWER-FIRST: Reveal the core secret in the first paragraph.
          4. LINKING: You MUST naturally weave in 1 link from the 'PAST ARTICLES' list.
          5. TONE: Cynical, smart, fast-paced.
          6. END: A specific prediction about what happens next.

          STRICT: NO EM-DASHES. UK English. ## Headers.

          OUTPUT FORMAT:
          TITLE: [High-Voltage Headline]
          DESCRIPTION: [Tease the scandal]
          IMAGE_CAPTION: [Cynical caption]
          CATEGORY: [{topic.title()}]
          TAGS: [3 tags]
          IMAGE_KEYWORD: [2 metaphorical words, e.g. "Storm", "Fire", "Handshake"]
          BODY: [Full Article]"""

          output = run_gemini(prompt)
          if not output: exit(1)

          # --- 4. PARSE & CLEAN ---
          def extract(key, text):
              m = re.search(rf"^{key}:\s*(.*)", text, re.M | re.I)
              return m.group(1).strip() if m else None

          parsed = {
              "TITLE": extract("TITLE", output) or target_article['title'],
              "DESC": extract("DESCRIPTION", output) or "Full story inside.",
              "CAPTION": extract("IMAGE_CAPTION", output) or "Developing story.",
              "IMG": extract("IMAGE_KEYWORD", output) or topic,
              "BODY": ""
          }

          body_match = re.search(r"BODY:\s*(.*)", output, re.S | re.I)
          if body_match:
              parsed["BODY"] = body_match.group(1).strip()
          else:
              parsed["BODY"] = output.split("BODY:")[-1].strip()

          for k in parsed:
              parsed[k] = parsed[k].replace("—", ", ").replace("–", ", ").replace("--", ", ")
              parsed[k] = re.sub(r'(?i)(In conclusion|To summarize|Conclusion),?.*', '', parsed[k]).strip()

          # --- 5. PUBLISH & SEO SCHEMA ---
          date_now = datetime.datetime.utcnow().date().strftime('%Y-%m-%d')
          slug = re.sub(r'[^a-z0-9-]', '-', parsed["TITLE"].lower()).strip('-')
          u_key = os.environ.get("UNSPLASH_ACCESS_KEY")
          
          def get_img(q):
              try:
                  r = requests.get(f"https://api.unsplash.com/photos/random?query={q}&orientation=landscape&client_id={u_key}", timeout=10)
                  return r.json()['urls']['regular']
              except: return "https://images.unsplash.com/photo-1504711432869-efd597cdd042"
          
          img_url = get_img(parsed['IMG'])

          # SEO UPGRADE: Enhanced Person Schema for E-E-A-T
          schema_json = {
              "@context": "https://schema.org",
              "@type": "AnalysisNewsArticle",
              "headline": parsed['TITLE'],
              "description": parsed['DESC'],
              "datePublished": date_now,
              "author": {
                  "@type": "Person",
                  "name": "Jonathan Mwaniki",
                  "jobTitle": "Investigative Columnist",
                  "url": "https://jonathanmwaniki.co.ke" 
              },
              "image": [img_url]
          }

          final_md = textwrap.dedent(f"""---
          title: "{parsed['TITLE'].replace('"', "'")}"
          description: "{parsed['DESC'].replace('"', "'")}"
          date: "{date_now}"
          author: "Jonathan Mwaniki"
          image: "{img_url}"
          imageCaption: "{parsed['CAPTION'].replace('"', "'")}"
          category: "{topic.title()}"
          slug: "{slug}"
          ---

          {parsed['BODY']}

          <script type="application/ld+json">
          {json.dumps(schema_json, indent=2)}
          </script>
          """).strip()

          out_dir = os.environ.get("POSTS_DIR")
          os.makedirs(out_dir, exist_ok=True)
          with open(os.path.join(out_dir, f"{slug}.md"), "w", encoding="utf-8") as f: f.write(final_md)
          
          memory.append(final_hash)
          with open(memory_path, 'w') as f: json.dump(memory[-200:], f)
          EOF

      - name: Git Safety Pull
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git stash -u
          git fetch origin main
          git pull origin main --rebase
          git stash pop || echo "Nothing to pop"

      - name: Commit and push
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "content: seo-safe scandal publish"
          branch: ${{ env.DEFAULT_BRANCH }}
          file_pattern: 'src/content/posts/*.md .github/scrape_memory.json'